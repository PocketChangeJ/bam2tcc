/**
 * readGTFs and readSAMs plus helper functions. See structs.hpp for more info
 * about the structs used.
 */

#include <iostream>
#include <algorithm>
#include <future>
#include <seqan/bam_io.h>
#include "sam_io.hpp"
#include "util.hpp"
#include "semaphore.hpp"
using namespace std;

typedef seqan::FormattedFileContext<seqan::BamFileIn, void>::Type TBamContext;

/**
 * @brief Gets "exons" of a read.
 *
 * Looks at CIGAR string to determine where a read was split up across different
 * exons, and returns a vector containing the exons of the read.
 *
 * @param r         Read to examine. CIGAR string should be entirely lowercase.
 * @return          Vector of exons
 */
vector<Exon> get_read_exon_positions(seqan::BamAlignmentRecord &r) {
    vector<Exon> exons;
    int start = r.beginPos, end = start;
    for (uint i = 0; i < seqan::length(r.cigar); ++i) {
        switch (r.cigar[i].operation) {
            case 'M':
            case 'D':
            case '=':
            case 'X': end += r.cigar[i].count;
                      break;
            case 'N': exons.push_back(Exon(start, end));
                      start = end + r.cigar[i].count;
                      end = start;
                      break;
            default: /* do nothing */ break;
        }
    }
    if (end == r.beginPos) {
        cerr << "  COMPLAINS LOUDLY" << endl;
    }
    exons.push_back(Exon(start, end));
    return exons;
}

/**
 * @brief Gets all possible transcripts associated with read exon vector (for
 * use with get_read_exon_positions function). That is, the function fills in
 * the "transcripts" member of the exon struct.
 *
 * @param chrom         Exons of the chromosome/scaffold the read aligns to.
 * @param read_exons    Vector of exons to fill with transcript information.
 * @postcondition       Transcripts member of exons in read_exons filled.
 */
void get_read_exon_transcripts(const vector<Exon> &chrom,
                               vector<Exon> &read_exons) {
   
    for (uint i = 0; i < chrom.size(); ++i) {
        for (uint j = 0; j < read_exons.size(); ++j) {
            if (read_exons[j].start >= chrom[i].start
                && read_exons[j].end <= chrom[i].end) {
                read_exons[j].transcripts->insert(
                    read_exons[j].transcripts->end(),
                    chrom[i].transcripts->begin(), chrom[i].transcripts->end());
            }
        }
    }
}

/**
 * @brief Gets string representation of the equivalence class of a read
 * based on the information contained in vector exons.
 *
 * @param exons     Vector containing information about annotated sequences
 * as generated by readGTFs method.
 *
 * @param read      Read struct containing information about read.
 *
 * @return          String representation of equivalence class. Comma-separated,
 * no spaces. Transcripts are described by an index which corresponds either to
 * where it showed up in the GTFs, or to where it shows up in the FASTA
 * transcriptome file if that option was used. See readGTFs for more info.
 */
vector<int> get_eq(const vector<vector<Exon>*> &exons, TBamContext &cont,
        seqan::BamAlignmentRecord rec) {
    vector<int> eq;

    /* Find the vector describing the chromosome/scaffold this read aligned
     * to. If we can't find it, return immediately.*/
    vector<Exon> *chrom = NULL;
    for (uint i = 0; i < exons.size(); ++i) {
        if (exons[i]->size() != 0
            && lower(string(seqan::toCString(
                    seqan::contigNames(cont)[rec.rID]))).compare(
                    ((*exons[i])[0]).seqname) == 0) {
            chrom = exons[i];
            break;
        }
    }
    if (chrom == NULL) {
        return eq;
    }

    /* Get "exons" of this read and fill in their associated transcript
     * vectors. */
    vector<Exon> read_exons = get_read_exon_positions(rec);
    get_read_exon_transcripts(*chrom, read_exons);
    
    /* Take the intersection of all the transcripts the read exons aligned
     * to, which gives the equivalence class of this read. */
    vector<int> inter(*read_exons[0].transcripts);
    sort(inter.begin(), inter.end()); 
    for (uint i = 1; i < read_exons.size(); ++i) {
        vector<int> temp;
        vector <int> *curr_transcripts = read_exons[i].transcripts;
        /* Sort transcripts in preparation for set_intersection. */
        sort(curr_transcripts->begin(), curr_transcripts->end());
        set_intersection(inter.begin(), inter.end(),
                         curr_transcripts->begin(), curr_transcripts->end(),
                         back_inserter(temp));
        inter = temp;
    }
    /* Remove duplicates. inter is already sorted! */
    inter.erase(unique(inter.begin(), inter.end()), inter.end());
    return inter;
}

/**
 * @brief Reads input SAM file and populates vector eqs with equivalence class
 * counts based on the annotated GTF sequences in vector seqs. Prints error
 * message if file cannot be opened.
 *
 * @param[in] file      Name of SAM file containing information about reads
 *
 * @param[in] seqs      Vector containing information on annotated sequences.
 * Sequences should at least contain an ID, a start index, and an end index.
 *
 * @param[in, out] eqs  (Empty) vector to populate with information about
 * equivalence classes. New Equivalence_Class structs will be allocated as
 * necessary.
 *
 * @return -1 if file fails to open, else 0
 */
int readSAM(string file, int filenumber, int start, int end, int thread,
            vector<vector<Exon>*> &exons, TCC_Matrix &matrix,
            string unmatched_outfile, int verbose, Semaphore &sem) {

    uint64_t line_count = 0;
    if (end == 0) {
        end = get_line_count(file);
    }
    uint64_t lines = end - start;
    uint64_t ten_percent = lines / 10;
    if (lines <= 0) {
        return -1;
    }

    seqan::BamFileIn bam;
    if (!seqan::open(bam, file.c_str())) {
        sem.dec();
        cerr << "  ERROR: failed to open " << file << endl;
        sem.inc();
        return -1;
    }

    /* Everything after this is a bit convoluted. Mostly because I can't find a
     * way to "unread" a line, as it were. */
    seqan::BamAlignmentRecord rec;
    seqan::BamAlignmentRecord rec2;
    seqan::BamHeader header;
    seqan::readHeader(header, bam);
    TBamContext cont = context(bam);

    /* Read in the first line. */
    if (start == 0) {
        ++line_count;
        seqan::readRecord(rec, bam);
    } else {
        while (line_count < start - 1) {
            ++line_count;
            seqan::readRecord(rec, bam);
        }
        string qName = seqan::toCString(rec.qName);
        ++line_count;
        seqan::readRecord(rec, bam);
        /* If `start` is in the middle of a multimapping (multientry) read,
         * keep going until it's done. */
        while (!atEnd(bam)
                && qName.compare(seqan::toCString(rec.qName)) == 0) {
            ++line_count;
            seqan::readRecord(rec, bam);
        }
    }
    string qName = seqan::toCString(rec.qName);
    vector<int> eq;
    if (seqan::hasFlagMultiple(rec)) {
        ++line_count;
        seqan::readRecord(rec2, bam);
        if (!seqan::hasFlagUnmapped(rec) && !seqan::hasFlagUnmapped(rec2)) { 
            /* eq = intersect(get_eq(rec), get_eq(rec2)) */
            /* get_eq returns a sorted vector, so no need to sort here. */
            vector<int> temp1 = get_eq(exons, cont, rec);
            vector<int> temp2 = get_eq(exons, cont, rec2);
            set_intersection(temp1.begin(), temp1.end(),
                    temp2.begin(), temp2.end(), back_inserter(eq));
            /* Remove duplicates. eq is already sorted. */
            eq.erase(unique(eq.begin(), eq.end()), eq.end());
        }
    } else {
        if (!seqan::hasFlagUnmapped(rec)) {
            eq = get_eq(exons, cont, rec);
        }
    }

    /* Start looping through the rest of the file. */
    int unmatched = 0;
    while (!atEnd(bam)) {
        ++line_count;
        seqan::readRecord(rec, bam);

        /* If this is a new read (i.e. new qName), enter the TCC of the previous
         * one into the matrix. */
        if (qName.compare(seqan::toCString(rec.qName)) != 0) {
            if (line_count >= end) {
                break;
            }
            if (eq.size() == 0) {
                ++unmatched;
            } else {
                string string_eq = to_string(eq[0]);
                for (int i = 1; i < eq.size(); ++i) {
                    string_eq += ',' + to_string(eq[i]);
                }
                matrix.inc_TCC(string_eq, filenumber);
                eq.clear();
            }
            qName = seqan::toCString(rec.qName);
        }

        if (seqan::hasFlagUnmapped(rec)) {
            if (seqan::hasFlagMultiple(rec)) {
                ++line_count;
                seqan::readRecord(rec2, bam);
            }
            continue;
        }
        vector<int> temp_eq = get_eq(exons, cont, rec);
        if (seqan::hasFlagMultiple(rec)) {   
            ++line_count;
            seqan::readRecord(rec2, bam);
            if (seqan::hasFlagUnmapped(rec2)) {
                continue;
            } else {
                /* temp_eq = intersect(temp_eq, get_eq(rec2)) */
                vector<int> temp1 = get_eq(exons, cont, rec2);
                vector<int> temp2;
                set_intersection(temp_eq.begin(), temp_eq.end(),
                temp1.begin(), temp1.end(), back_inserter(temp2));
                temp_eq = temp2;
                /* Remove duplicates. temp_eq is already sorted. */
                temp_eq.erase(unique(temp_eq.begin(), temp_eq.end()),
                    temp_eq.end());
            }
        }
        /* eq = union(eq, temp_eq) */
        eq.insert(eq.end(), temp_eq.begin(), temp_eq.end());
        sort(eq.begin(), eq.end());
        /* Remove duplicates. */
        eq.erase(unique(eq.begin(), eq.end()), eq.end());
    }

    /* The last read was never added to the matrix. Do so now. */
    if (eq.size() == 0) {
        ++unmatched;
    } else {
        string string_eq = to_string(eq[0]);
        for (int i = 1; i < eq.size(); ++i) {
            string_eq += ',' + to_string(eq[i]);
        }
        matrix.inc_TCC(string_eq, filenumber);
    }

    /* TODO: output unmatched reads. */

    return unmatched;
}

int readSAMs(vector<string> &files,
             vector<vector<Exon>*> &exons, TCC_Matrix &matrix,
             string unmatched_outfile, int verbose, int nthreads) {
   
    // Vector of all our possible threads. 
    vector<future<int>> unmatched;

    // Used to coordinate stdout, stderr, and shared file output.
    Semaphore sem;

    /* Figure out how to split up workload, e.g. whether we should just give
     each thread some number of files, or if we can set multiple threads on a
     single file. */
    // For now, assume all files are about the same size.
    if (files.size() <= nthreads) {
        int perfile = nthreads / files.size();
        for (int i = 0; i < files.size(); ++i) {
            int lines = get_line_count(files[i]);
            for (int j = 0; j < perfile - 1; ++j) {
                unmatched.push_back(async(launch::async, &readSAM, files[i], i,
                        lines / perfile * j, lines / perfile * (j + 1),
                        i * perfile + j,
                        ref(exons), ref(matrix), unmatched_outfile, verbose,
                        ref(sem)));
            }
            // Do the last thread separately becuse I'm paranoid that I'll get
            // an off-by-one error.
            unmatched.push_back(async(launch::async, &readSAM,
                    files[i], i,
                    lines / perfile * (perfile - 1), 0,
                    i * perfile + perfile - 1,
                    ref(exons), ref(matrix), unmatched_outfile, verbose,
                    ref(sem)));
        }
    } else {
    }

    int total_unmatched = 0;
    for (int i = 0; i < unmatched.size(); ++i) {
        if (unmatched[i].valid()) {
            unmatched[i].wait();
        }
        else {
            cout << "invalid state?" << endl;
        }
        int temp = unmatched[i].get();
        if (temp == -1) {
            cerr << "  WARNING: thread " << i << " failed" << endl;
        }
        else {
            total_unmatched += temp;
        }
    }

    return total_unmatched;
}

