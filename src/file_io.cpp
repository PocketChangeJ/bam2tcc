/**
 * readGTFs and readSAMs plus helper functions. See structs.hpp for more info
 * about the structs used.
 */

#include <iostream>
#include <algorithm>
#include <future>
#include <seqan/bam_io.h>

#include "file_io.hpp"
#include "util.hpp"
#include "kallisto_util.hpp"
#include "semaphore.hpp"

using namespace std;

/**
 * @brief Returns a vector allocated on the heap containing all exons in map.
 *
 * @param m     Map containing exons to place in vector.
 * @return      Vector containing exons.
 */
vector<Exon> *map_values(unordered_map<string, Exon> &m) {
    vector<Exon> *vec = new vector<Exon>;
    for (unordered_map<string, Exon>::iterator it = m.begin();
         it != m.end(); ++it) {
        vec->push_back(Exon(it->second));
    }
    return vec;
}

/**
 * @brief Gets "exons" of a read.
 *
 * Looks at CIGAR string to determine where a read was split up across different
 * exons, and returns a vector containing the exons of the read.
 *
 * @param r         Read to examine. CIGAR string should be entirely lowercase.
 * @return          Vector of exons
 */
vector<Exon> get_read_exon_positions(const Read &r) {
    vector<Exon> exons;
    
    string count = "";
    int start = r.pos, end = start;
    for (uint i = 0; i < r.cigar.size(); ++i) {
        if (isdigit(r.cigar[i])) {
            count += r.cigar[i];
        }
        else {
            if (string(1, r.cigar[i]).find_first_of("md=x") != string::npos) {
                end += stoi(count) - 1;
            }
            else if (r.cigar[i] == 'n') {
                exons.push_back(Exon(start, end));
                start = end + stoi(count) + 1;
                end = start;
            }
            count = "";
        }
    }
    if (end != start) {
        exons.push_back(Exon(start, end));
    }
    
    return exons;
}

/**
 * @brief Gets all possible transcripts associated with read exon vector (for
 * use with get_read_exon_positions function). That is, the function fills in
 * the "transcripts" member of the exon struct.
 *
 * @param chrom         Exons of the chromosome/scaffold the read aligns to.
 * @param read_exons    Vector of exons to fill with transcript information.
 * @postcondition       Transcripts member of exons in read_exons filled.
 */
void get_read_exon_transcripts(const vector<Exon> &chrom,
                               vector<Exon> &read_exons) {
    
    for (uint i = 0; i < chrom.size(); ++i) {
        for (uint j = 0; j < read_exons.size(); ++j) {
            if (read_exons[j].start >= chrom[i].start
                && read_exons[j].end <= chrom[i].end) {
                read_exons[j].transcripts->insert(
                    read_exons[j].transcripts->end(),
                    chrom[i].transcripts->begin(), chrom[i].transcripts->end());
            }
        }
    }
}

/**
 * @brief Gets string representation of the equivalence class of a read
 * based on the information contained in vector exons.
 *
 * @param exons     Vector containing information about annotated sequences
 * as generated by readGTFs method.
 *
 * @param read      Read struct containing information about read.
 *
 * @return          String representation of equivalence class. Comma-separated,
 * no spaces. Transcripts are described by an index which corresponds either to
 * where it showed up in the GTFs, or to where it shows up in the FASTA
 * transcriptome file if that option was used. See readGTFs for more info.
 */
string get_eq(const vector<vector<Exon>*> &exons, Read &read) {
    // Find the vector describing the chromosome/scaffold this read aligned to.
    vector<Exon> *chrom = NULL;
    for (uint i = 0; i < exons.size(); ++i) {
        if (exons[i]->size() != 0
            && read.rname.compare(((*exons[i])[0]).seqname) == 0) {
            chrom = exons[i];
            break;
        }
    }
    // If we don't find it, we can't get the equivalence class.
    if (chrom == NULL) {
        return "";
    }
    
    // Get "exons" of this read and fill in their associated transcript vectors.
    vector<Exon> read_exons = get_read_exon_positions(read);
    get_read_exon_transcripts(*chrom, read_exons);
    
    // Stores intersection of all exon.transcripts vectors.
    // Assumption: read_exons non-empty. The read exists, so read_exons contains
    // at least one exon describing either the entire read, or the first part of
    // it. Sort it in preparation for set_intersection.
    vector<uint64_t> inter(*read_exons[0].transcripts);
    sort(inter.begin(), inter.end());
    
    for (uint i = 1; i < read_exons.size(); ++i) {
        vector<uint64_t> temp; // Temporarily store intersection here.
        vector <uint64_t> *curr_transcripts = read_exons[i].transcripts;
        
        // Sort transcripts in preparation for set_intersection.
        sort(curr_transcripts->begin(), curr_transcripts->end());
        
        // Get intersection of inter and transcripts of this exon. Store in
        // temp. We need to use back_inserter(temp), since set_intersection
        // will usually overwrite the elements in whatever vector it's inserting
        // into. Since temp is empty, there is nothing to overwrite, and using
        // temp.begin() will segfault 11. We instead want to add elements--thus,
        // we need back_inserter.
        set_intersection(inter.begin(), inter.end(),
                         curr_transcripts->begin(), curr_transcripts->end(),
                         back_inserter(temp));
        
        // Transfer intersection in temp to inter.
        inter = temp;
    }
    
    // Sort so that the equivalence class string lists the transcripts in the
    // same order each time.
    sort(inter.begin(), inter.end());
    
    string eq = "";
    for (uint i = 0; i < inter.size(); ++i) {
        eq += to_string(inter[i]) + ",";
    }
    return eq.substr(0, eq.size() - 1); // Get rid of the last comma.
}


/**
 * @brief Get length of the aligned region of the read.
 
 * This is not necessarily equivalent to the length of the read, since the CIGAR
 * string may indicate, for example, a base pair that had been deleted. Then,
 * this function would return (length of read) + 1.
 *
 * @param r         Read to parse
 * @return          Length of read
 */
int get_read_length(const Read &r) {
    int len = 0;
    string count = "";
    for (uint i = 0; i < r.cigar.size(); ++i) {
        if (isdigit(r.cigar[i])) {
            count += r.cigar[i];
        }
        else {
            if (string(1, r.cigar[i]).find_first_of("md=x") != string::npos) {
                if (count.size() == 0) {
                    ++len;
                }
                else {
                    len += stoi(count);
                }
            }
            count = "";
        }
    }
    
    return len;
}


/**
 * @brief Populates and returns a newly allocated Read struct based on
 * information provided in string info, a line from a SAM file. Prints
 * warning message and returns NULL if error occurs while parsing string.
 *
 * @param[in] info a line in a SAM file with information about start and
 * end indices of read within genome
 *
 * @return New Read struct populated with available information. Returns
 * NULL if info does not contain the expected number of fields or if numerical
 * fields pos and end cannot be parsed.
 */
void get_read(string info, Read &read) {
    read.pos =  PARSE_FAILED;
    
    vector<string> fields = parse_tsv(info);
    if (fields.size() < NUM_SAM_ELT) {
        return;
    }
    
    read.cigar = fields[5];
    read.qname = fields[0];
    read.rname = fields[2];
    try {
        read.flag = stoi(fields[1]);
        read.pos = stoi(fields[3]);
        read.end = read.pos + get_read_length(read) - 1;
    }
    catch (invalid_argument &e) {
        read.pos = PARSE_FAILED;
    }
}

/**
 * @brief Populates and returns a newly allocated Sequence struct based on
 * information provided in string info, a line from a GTF file.
 *
 * @param[in] info   a line in a GTF file with information about feature (gene,
 *                   exon, transcript, etc.), start, and end in appropriate
 *                   locations. Ninth field "attribute" should contain
 *                   "transcript_id: " followed by transcript ID for optional
 *                   transcriptome-order output.
 *
 * @return New Sequence struct populated with available information. Returns
 * NULL if info does not contain the expected number of fields or if numerical
 * fields start and end cannot be parsed.
 */
Sequence get_sequence(string info) {
    Sequence seq;
    seq.start = 0;
    
    vector<string> fields = parse_tsv(info);
    if (fields.size() < NUM_GTF_ELT) {
        return seq;
    }
    
    seq.seqname = fields[0];
#if USING_GTF
    seq.feature = fields[2];
#else
    seq.feature = "exon";
#endif
    
#if USING_GTF
    seq.id = "";
    string id_start = ID_START;
    string id_end = ID_END;
    if (id_end.size() == 1) {
        int start = fields[8].find(id_start) + id_start.length();
        int end = fields[8].find(id_end, start + 1);
        if (start != string::npos && end != string::npos) {
            seq.id = fields[8].substr(start, end - start);
        }
    }
#else
    seq.id = fields[8];
#endif
    
    try {
        seq.start = stoi(fields[3]);
        seq.end = stoi(fields[4]);
    }
    catch (invalid_argument &e) {
        seq.start = 0;
    }
    return seq;
}


/**
 * @brief Reads input SAM file and populates vector eqs with equivalence class
 * counts based on the annotated GTF sequences in vector seqs. Prints error
 * message if file cannot be opened.
 *
 * @param[in] file      Name of SAM file containing information about reads
 *
 * @param[in] seqs      Vector containing information on annotated sequences.
 * Sequences should at least contain an ID, a start index, and an end index.
 *
 * @param[in, out] eqs  (Empty) vector to populate with information about
 * equivalence classes. New Equivalence_Class structs will be allocated as
 * necessary.
 *
 * @return -1 if file fails to open, else 0
 */
int readSAM(string file, int filenumber, int start, int end, int thread,
            vector<vector<Exon>*> &exons, TCC_Matrix &matrix,
            string unmatched_outfile, int verbose, Semaphore &sem) {
    
    string inp, upper_inp, prev_inp, prev_qname, eq;
    Read read;
    
    uint64_t unmatched = 0;
    vector<string> *unmatched_lines = new vector<string>;

    uint64_t line_count = 0;
    if (end == 0) {
        end = get_line_count(file);
    }
    uint64_t lines = end - start;
    uint64_t ten_percent = lines / 10;
    if (lines == -1) {
        return -1;
    }
   
    /* Open SAM file a file for unmatched output if the parameter for the name
     of this file is not an empty string. Return -1 if action fails */
    ifstream f(file);
    if (!f.is_open()) {
        return -1;
    }
//    seqan::BamFileIn bam(
//            seqan::toCString(seqan::getAbsolutePath(file.c_str())));
   
    sem.dec();
    cout << "  " << thread << ": reading lines " << start << ".." << end;
    cout << " of " << file << "..." << endl;
    sem.inc();

    /* Go to the starting line of this file. */
    while (line_count < start && getline(f, upper_inp)) {
        ++line_count;
    }
    
    /* Start looping through each line of the file */
    while(line_count < end && getline(f, upper_inp)) {
        /* Update line count and print update message */
        ++line_count;
#if 0
        if (verbose && line_count > MIN_UPDATE //&& thread == 0
                && (line_count - start) % ten_percent == 0) {        
            sem.dec();
            cout << "    ";
            cout << (line_count - start) / ten_percent << "0% done" << endl;
            sem.inc();
        }
#endif

        /* Skip header and blank lines */
        if (upper_inp.size() == 0 || upper_inp[0] == '@') {
            continue;
        }
        
        /* Parse input and place information in read */
        inp = lower(upper_inp);
        get_read(inp, read);
        
        /* Make sure read is valid. If not, skip it. */
        if (read.flag == 4) {
            // According to SAM specifications, this means it was not aligned.
            continue;
        }
        if (read.pos == PARSE_FAILED) {
            if (verbose) {
                sem.dec();
                cerr << "    WARNING: unable to parse line ";
                cerr << line_count << ". Make sure this line has 11 tab-";
                cerr << "separated fields, valid int values, and a";
                cerr << " CIGAR string" << endl;
                sem.inc();
            }
            continue;
        }
        
        /* Get equivalence class. How we do it depends on whether we've seen
           this read before. */
        if (prev_qname.compare(read.qname) == 0) {
            // Check whether this is a read that mapped to multiple locations.
            if (eq.size() == 0) {
                eq = get_eq(exons, read);
            } else {
                matrix.dec_TCC(eq, filenumber);
                string temp = get_eq(exons, read);
                if (temp.size() != 0) {
                    eq += ',' + temp;
                }
                vector<uint64_t> to_sort = parse_csv_ints(eq);
                sort(to_sort.begin(), to_sort.end());
                eq = "";
                for (uint i = 0; i < to_sort.size(); ++i) {
                    eq += to_string(to_sort[i]) + ',';
                }
                eq = eq.substr(0, eq.size() - 1); // Get rid of last comma.
            }
        }
        else {
            // Update unmatched if the last read didn't align anywhere.
            if (eq.size() == 0) {
                ++unmatched;
                unmatched_lines->push_back(prev_inp);
            }

            // This is a new read. We just want to get the equivalence class
            // and update prev_qname.
            eq = get_eq(exons, read);
            prev_qname = read.qname;
        }
        
        /* And finally, add it to the matrix! */
        if (eq.size() != 0) {
            matrix.inc_TCC(eq, filenumber);
        }
        prev_inp = upper_inp;
    }


    /* Attempt to open output file for unmatched reads if outname of this file
     is nonempty. Print warning message if action fails */
    if (unmatched_outfile.size() != 0) {
        ofstream fout(unmatched_outfile, fstream::app);
        sem.dec();
        if (!fout.is_open()) {
            cerr << "    WARNING: unable to open " << unmatched_outfile << endl;
        }
        else{
            for (int i = 0; i < unmatched_lines->size(); ++i) {
                fout << (*unmatched_lines)[i] << endl;
            }
            fout.close();
        }
        sem.inc();
    }

    /* Clean-up and return */
    f.close();
    
    return unmatched;
}

int readSAMs(vector<string> &files,
             vector<vector<Exon>*> &exons, TCC_Matrix &matrix,
             string unmatched_outfile, int verbose, int nthreads) {
   
    // Vector of all our possible threads. 
    vector<future<int>> unmatched;

    // Used to coordinate stdout, stderr, and shared file output.
    Semaphore sem;

    /* Figure out how to split up workload, e.g. whether we should just give
     each thread some number of files, or if we can set multiple threads on a
     single file. */
    // For now, assume all files are about the same size.
    if (files.size() <= nthreads) {
        int perfile = nthreads / files.size();
        for (int i = 0; i < files.size(); ++i) {
            int lines = get_line_count(files[i]);
            for (int j = 0; j < perfile - 1; ++j) {
                unmatched.push_back(async(launch::async, &readSAM, files[i], i,
                        lines / perfile * j, lines / perfile * (j + 1),
                        i * perfile + j,
                        ref(exons), ref(matrix), unmatched_outfile, verbose,
                        ref(sem)));
            }
            // Do the last thread separately becuse I'm paranoid that I'll get
            // an off-by-one error.
            unmatched.push_back(async(launch::async, &readSAM,
                    files[i], i,
                    lines / perfile * (perfile - 1), 0,
                    i * perfile + perfile - 1,
                    ref(exons), ref(matrix), unmatched_outfile, verbose,
                    ref(sem)));
        }
    } else {
    }

    int total_unmatched = 0;
    for (int i = 0; i < unmatched.size(); ++i) {
        if (unmatched[i].valid()) {
            unmatched[i].wait();
        }
        else {
            cout << "invalid state?" << endl;
        }
        int temp = unmatched[i].get();
        if (temp == -1) {
            cerr << "  WARNING: thread " << i << " failed" << endl;
        }
        else {
            total_unmatched += temp;
        }
    }

    return total_unmatched;
}

/**
 * @brief Reads annotated sequences in (GTF) file. Attribute (9th) field should
 * contain "transcript_id: " followed by the transcript ID with no spaces.
 *
 * Note: assumes that information about a single chromosome/scaffold will not
 * be spread across multiple GTF files.
 *
 * @param file                  name of (GTF) file containing annotated
 *                              sequences
 * @param transcripts           (empty) vector to fill with sequence information
 * @param verbose               if 1, output warning messages to std::cerr
 * @param seq_count_start       number at which to start indexing transcripts.
 *                              if this is the first GTF, it should be 0, else
 *                              wherever the last GTF stopped
 *
 * @return                      1 if file fails to open, else 0
 */
int readGTF(string file, unordered_map<uint64_t, uint64_t> index_map,
            vector<vector<Exon>*> &exons, uint64_t &transcript_count,
            int verbose) {
    
    // Holds one line of the file. For use with getline.
    string inp;
    
    // seqname and id of previous exon. For use with seq_count.
    string prev_seqname = "", prev_id = "";
    
    // Maps "start,end" to exon in ONE chromosome or scaffold. Add info to
    // vector exons and clear whenever a new chromosome or scaffold is
    // encountered.
    unordered_map<string, Exon> chrom;
    
    // Number of current line being read. For use in error messages if a line
    // cannot be parsed.
    uint64_t line_count = 0;
    
    // Total number of lines in file. If verbose, prints update messages every
    // 10% done.
    uint64_t lines = get_line_count(file);
    if (lines == -1) { // File could not be opened! Return 1.
        return 1;
    }
    // 10% of the file. If verbose, prints update messages every ten_percent
    // lines.
    uint64_t ten_percent = lines / 10;
    
    /* Open GTF files. Return 1 if error occurs */
    ifstream f(file);
    if (!f.is_open()) {
        return 1;
    }
    
    cout << "  Reading " << file << "..." << endl;
    
    /* Start while loop to go through GTF file */
    while(getline(f, inp)) {
        /* Update line count and print update message */
        ++line_count;
        if (verbose && lines > MIN_UPDATE && line_count % ten_percent == 0) {
            cout << "    " << line_count / ten_percent << "0% done" << endl;
        }
        
        /* Skip header and blank lines */
        if (inp.size() == 0 || inp[0] == '#') {
            continue;
        }
        
        /* Parse input and place information in seq */
        inp = lower(inp);
        Sequence seq = get_sequence(inp);
        
        /* Look at values and update vector exons, map chrom, and various
         counters appropriately */
        if (seq.start == 0) {
            if (verbose) {
                cerr << "    WARNING: Failed to read line ";
                cerr << line_count << endl;
            }
        }
        else if (seq.seqname.size() == 0) {
            if (verbose) {
                cerr << "    WARNING: Line " << line_count;
                cerr << " contains no information in seqname field" << endl;
            }
        }
        else if (seq.feature.compare("exon") == 0) {
            // Key for map chrom.
            string key = to_string(seq.start) + "," + to_string(seq.end);
            
            // Are we looking at the same chromosome/scaffold? If so, we update
            // the relevant exon in map chrom.
            if (prev_seqname.compare(seq.seqname) == 0) {
                // Only update seq_count if we're looking at an exon in
                // a new transcript.
                if (prev_id.compare(seq.id) != 0) {
                    ++transcript_count;
                    prev_id = seq.id;
                }
                
                uint64_t id;
                if (!index_map.empty()) {
                    try {
                        id = index_map.at(transcript_count);
                    }
                    catch (out_of_range &err) {
                        id = -1;
                        cerr << "  WARNING: unable to map index ";
                        cerr << transcript_count << " to transcriptome's. ";
                        cerr << "It will show up in EC as " << id <<  ".";
                        cerr << endl;
                    }
                }
                else {
                    id = transcript_count;
                }
                
                if (chrom.find(key) == chrom.end()) {
                    chrom.emplace(key, Exon(seq));
                }
                chrom.at(key).transcripts->push_back(id);
            }
            
            // It's a new chromosome/scaffold, so we need to clear map chrom
            // and create a new vector in which to place the exon.
            else {
                // Update seqname.
                prev_seqname = seq.seqname;
                
                // If we have something in chrom, we add it to vector exons
                // and clear it.
                if (!chrom.empty()) {
                    exons.push_back(map_values(chrom));
                    chrom.clear();
                }
                
                // This is definitely a new transcript, so update.
                ++transcript_count;
                prev_id = seq.id;
                
                uint64_t id;
                if (!index_map.empty()) {
                    try {
                        id = index_map.at(transcript_count);
                    }
                    catch (out_of_range &err) {
                        id = -1;
                        cerr << "  WARNING: unable to map index ";
                        cerr << transcript_count << " to transcriptome's. ";
                        cerr << "It will show up in EC as " << id << ".";
                        cerr << endl;
                    }
                }
                else {
                    id = transcript_count;
                }
                
                // Add the new exon to the now-empty map chrom.
                chrom.emplace(key, Exon(seq));
                chrom.at(key).transcripts->push_back(id);
            }
        }
    }
    
    // Add the exons from the last-encountered chromosome/scaffold.
    if (!chrom.empty()) {
        exons.push_back(map_values(chrom));
    }
    
    f.close();
    return 0;
}

/**
 *
 */
int readGTFs(vector<string> &files, vector<string> &transcriptome,
             vector<vector<Exon>*> &exons, int verbose) {
    // 0-index the transcript counts. This will make count start at 0.
    uint64_t transcript_count = -1;
    
    // Map from this program's transcript indexing to kallisto's.
    unordered_map<uint64_t, uint64_t> *index_map
    = new unordered_map<uint64_t, uint64_t>;
    
    if (transcriptome.size() != 0) {
        int ret = get_index_to_kallisto_index(files, transcriptome, *index_map,
                                              verbose);
        if (ret == 1) {
            // It prints its own error message, so just return 1.
            return 1;
        }
    }
    
    for (uint i = 0; i < files.size(); ++i) {
        int ret = readGTF(files[i], *index_map, exons,
                          transcript_count, verbose);
        if (ret == 1) {
            cerr << "  ERROR: could not read " << files[i] << endl;
            return 1;
        }
    }
    
    delete index_map;
    
    return transcript_count;
}
